	//update ghost movements and locations
	public void updateGhost(){
		int gNormalSpeed = ghosts.get(0).getNormalSpeed();
		int XmodW, YmodH;
		int boxX, boxY;
		int gX, gY;
		
		
		for (int i = 0; i < ghosts.size(); i++) {
			gX = ghosts.get(i).getX();
			gY = ghosts.get(i).getY();
			XmodW = gX % blockSize;
			YmodH = gY % blockSize;
			boolean movable = true;

			int ghostNewDir = ghosts.get(i).getDir();
			int randDirection = ghostNewDir;
			
			// check direction and change if it is allowed
			if (XmodW == 0 && YmodH == 0) {
				randDirection = ((int)Math.random()*4) + 1;
				boxX = gX / blockSize;
				boxY = gY / blockSize;

				if (randDirection == 4) { // move left allowed if can move to left
					if (boxX > 0)
						if (mazeArray[boxY][boxX - 1] != 0)
							ghostNewDir = randDirection;
				}
				if (randDirection == 3) { // move right
					if (boxX < mazeColumn)
						if (mazeArray[boxY][boxX + 1] != 0)
							ghostNewDir = randDirection;
				}
				if (randDirection == 2) { // move down
					if (boxY < mazeRow)
						if (mazeArray[boxY + 1][boxX] != 0)
							ghostNewDir = randDirection;
				}
				if (randDirection == 1) { // move up
					if (boxY > 0)
						if (mazeArray[boxY - 1][boxX] != 0)
							ghostNewDir = randDirection;
				}
			} else {
				if (newDirection != randDirection) {
					if (((randDirection == 1) || (randDirection == 2))
							&& (XmodW == 0) && (YmodH != 0)) {
						ghostNewDir = randDirection;
					}
					if (((randDirection == 3) || (randDirection == 4))
							&& (YmodH == 0) && (XmodW != 0)) {
						ghostNewDir = randDirection;
					}
				}
			}

			ghosts.get(i).setDir(ghostNewDir);

			// evaluate at intersection, collision detection
			if (XmodW == 0 && YmodH == 0) {
				boxX = gX / blockSize;
				boxY = gY / blockSize;

				movable = true;

				if (ghostNewDir == 4) { // move left
					if (boxX > 0)
						if (mazeArray[boxY][boxX - 1] == 0) {
							movable = false;
						}
				}

				if (ghostNewDir == 3) { // move right
					if (boxX < mazeColumn - 1)
						if (mazeArray[boxY][boxX + 1] == 0) {
							movable = false;
						}
				}

				if (ghostNewDir == 2) { // move down
					if (boxY < mazeRow - 1)
						if (mazeArray[boxY + 1][boxX] == 0) {
							movable = false;
						}
				}
				if (ghostNewDir == 1) { // move up
					if (boxY > 0)
						if (mazeArray[boxY - 1][boxX] == 0) {
							movable = false;
						}
				}

			}

			if (movable) {
				if (ghostNewDir == 1) // up
					gY = gY - gNormalSpeed;
				if (ghostNewDir == 2) // down
					gY = gY + gNormalSpeed;
				if (ghostNewDir == 3) // right
					gX = gX + gNormalSpeed;
				if (ghostNewDir == 4) // left
					gX = gX - gNormalSpeed;
			}

			ghosts.get(i).setX(gX);
			ghosts.get(i).setY(gY);

		}
	}
	